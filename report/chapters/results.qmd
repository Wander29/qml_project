# Results

I ran multiple test with various ansatzes. 

For convolution ansatz (a) (see @fig-conv_ansatzes) and pooling ansatz (1) I obtained the following results:

```{python}
#| echo: false
#| tbl-cap: a
#| tbl-colwidths: [40, 30, 30]
#| output: asis

import pandas as pd
df = pd.read_csv("../../scripts/results/out_2024-03-27_12-03-11.csv")
df.sort_values(by=['mean_test_score'], ascending=False, inplace=True)

a = pd.concat( 
    (
      df["param_model__share_weights"], 
      df["param_model__stride_c"], 
      df["param_model__step_c"], 
      df["param_model__filter_p"], 
      df["param_model__stride_p"], 
      df["mean_test_score"]) ,
  axis=1)
a.columns = ["Share weights", "Conv. stride", "Conv. step", "Pool. filter", "Pool. stride", "Mean validation score"]
a

```

The best configuration with `share_weights=True` selected was:

- `convolution_stride`: 7
- `convolution_step`: 1
- `pooling filter`: !*!
- `pooling stride`: 3

While the best configuration with `share_weights=False` selected was:
- `convolution_stride`: 1
- `convolution_step`: 1
- `pooling filter`: *!
- `pooling stride`: 2

Measuring them with the test set I obtain:

```{python}
df = pd.DataFrame( {
  'share weights': [False, True],
  "accuracy":[0.83, 0.7],
  "parameters": [32,12]
})
df
```

These are the results with the same convolution ansatz but with ansatz pooling (2):

