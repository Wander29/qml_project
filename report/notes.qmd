
## Barren Plateaus

-  where the gradient of a cost function vanishes exponentially with system size, rendering the architecture untrainable for large problem sizes

- Random circuits are often proposed as initial guesses for exploring the space of quantum states

- Due to exponential dimension of Hilbert space and the gradient estimation complexity on more than a few qubits

-   For a wide class of PQCs, the probability that the gradient along any reasonable direction is non-zero to some fixed precision is exponentially small as a function of the number of qubits @McClean2018Nov

### Barren Plateaus on QCNNs

- The variance of the gradient vanishes no faster than polynomially @Pesah2021Oct so QCNNs do not exhibit _barren plateaus_. 

- It is guaranteed that randomly initialized QCNNs are trainable, unlike many other QNN architectures.

## QCNNs

Introduced in @Cong2019Dec

## NAS

## HierarQcal
HierarQcal is an open-source python package @github_hierarqcal that simplifies the process of creating general quantum convolutional neural networks (QCNNs) by enabling an hierarchical design process. 
It makes automatic generation of QCNN circuits easy and it facilitates QCNN search space design for neural architecture search (NAS).
The package includes primitives such as _convolutions, pooling_ and _dense layers_ that can be stacked together hierarchically to form complex QCNN circuit architectures.

### Implementation

```{python}
import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
from hierarqcal import (
    Qhierarchy,
    Qcycle,
    Qpermute,
    Qmask,
    Qunmask,
    Qpivot,
    Qinit,
    Qmotif,
    Qmotifs,
    plot_motif,
    plot_circuit,
    Qunitary,
)
```

```{python}
import pennylane as qml
from hierarqcal.pennylane.pennylane_circuits import V2, U2, V4

def get_circuit(hierq):
    dev = qml.device("default.qubit", wires=hierq.tail.Q)

    @qml.qnode(dev)
    def circuit():
        if isinstance(next(hierq.get_symbols(), False), sp.Symbol):
            # Pennylane doesn't support symbolic parameters, so if no symbols were set (i.e. they are still symbolic), we initialize them randomly
            hierq.set_symbols(np.random.uniform(0, 2 * np.pi, hierq.n_symbols))
        hierq(
            backend="pennylane"
        )  # This executes the compute graph in order
        return [qml.expval(qml.PauliZ(wire)) for wire in hierq.tail.Q]

    return circuit

def draw_circuit(circuit, **kwargs):
    fig, ax = qml.draw_mpl(circuit)(**kwargs)
```


```{python}
m = Qcycle(1) + Qmask("right")
heirq = Qinit(8) + m*3
circuit = get_circuit(heirq)
draw_circuit(circuit)
```